# tests/test_linear_f2.py

# Tests for the hash_f2 class in src/hashing/linear_f2.py
# This test is generated by ChatGPT based on the provided code snippet.

import pytest
from src.hashing.linear_f2 import hash_f2


def parity_naive(v: int) -> int:
    """Return popcount(v) mod 2 without using bit_count/count('1') (independent check)."""
    p = 0
    while v:
        p ^= (v & 1)
        v >>= 1
    return p


def bit_at(y: int, i: int) -> int:
    return (y >> i) & 1


def test_M_rows_are_u_bit_ints_and_allow_zero():
    l, u = 64, 16
    h = hash_f2(l=l, u=u, seed=123, has_cpp=False)

    assert len(h.M) == l
    for row in h.M:
        assert isinstance(row, int)
        assert 0 <= row < (1 << u)  # includes 0 as valid value


def test_h_output_range_and_zero_vector():
    l, u = 12, 20
    h = hash_f2(l=l, u=u, seed=42, has_cpp=False)

    y0 = h.h(0)
    assert y0 == 0  # linear map => h(0)=0
    assert 0 <= y0 < (1 << l)

    x = (1 << (u - 1)) | 0b10101
    y = h.h(x)
    assert 0 <= y < (1 << l)


def test_h_rejects_out_of_range_x():
    l, u = 5, 8
    h = hash_f2(l=l, u=u, seed=7, has_cpp=False)

    with pytest.raises(ValueError):
        h.h(-1)

    with pytest.raises(ValueError):
        h.h(1 << u)  # exactly u+1 bits, out of allowed range


def test_h_matches_rowwise_dot_product_parity_independent():
    l, u = 16, 32
    h = hash_f2(l=l, u=u, seed=2026, has_cpp=False)

    # Try a few representative x values.
    xs = [
        0,
        1,
        (1 << (u - 1)),
        (1 << u) - 1,
        0xA5A5_A5A5 & ((1 << u) - 1),
    ]

    for x in xs:
        y = h.h(x)
        for i, row in enumerate(h.M):
            expected_bit = parity_naive(row & x)  # independent parity computation
            assert bit_at(y, i) == expected_bit


def test_linearity_over_f2_xor():
    """
    For linear maps over F2: h(x XOR y) == h(x) XOR h(y)
    """
    l, u = 20, 40
    h = hash_f2(l=l, u=u, seed=999, has_cpp=False)

    pairs = [
        (0, 0),
        (0, 12345),
        (1, 2),
        ((1 << (u - 1)), (1 << (u - 2))),
        ((1 << u) - 1, 0x123456789 & ((1 << u) - 1)),
    ]

    for x, y in pairs:
        assert h.h(x ^ y) == (h.h(x) ^ h.h(y))


def test_reproducibility_with_seed_same_params_same_M_and_same_hashes():
    l, u = 10, 25
    seed = 314159

    h1 = hash_f2(l=l, u=u, seed=seed, has_cpp=False)
    h2 = hash_f2(l=l, u=u, seed=seed, has_cpp=False)

    assert h1.M == h2.M

    xs = [0, 1, 7, (1 << (u - 1)), (1 << u) - 1, 0xABCDE & ((1 << u) - 1)]
    for x in xs:
        assert h1.h(x) == h2.h(x)


def test_different_seeds_usually_give_different_M():
    """
    Not a mathematical requirement, but a sanity check: different seeds should
    almost always produce a different matrix M.
    """
    l, u = 32, 64
    h1 = hash_f2(l=l, u=u, seed=1, has_cpp=False)
    h2 = hash_f2(l=l, u=u, seed=2, has_cpp=False)

    assert h1.M != h2.M
